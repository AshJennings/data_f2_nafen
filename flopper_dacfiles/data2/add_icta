#!/usr/bin/python3

import numpy
import requests
import io
import matplotlib.pyplot as plt
import argparse
from scipy.signal import savgol_filter

################################
# Add ICTA width as 9-th column

parser = argparse.ArgumentParser()
parser.add_argument('infile')
parser.add_argument('outfile')

parser.add_argument('--icta_plot', default='',
                    help='plot ICTA data to a png file')

parser.add_argument('--sm_win', default=21, type=int,
                    help='window for data smoothing')

parser.add_argument('--skip', default='',
                    help='skip points (1-2,30-40,5)')

args = parser.parse_args()



################################
# Smooth function from
# https://dsp.stackexchange.com/questions/1676/savitzky-golay-smoothing-filter-for-not-equally-spaced-data
def non_uniform_savgol(x, y, window, polynom):
    """
    Applies a Savitzky-Golay filter to y with non-uniform spacing
    as defined in x

    This is based on https://dsp.stackexchange.com/questions/1676/savitzky-golay-smoothing-filter-for-not-equally-spaced-data
    The borders are interpolated like scipy.signal.savgol_filter would do

    Parameters
    ----------
    x : array_like
        List of floats representing the x values of the data
    y : array_like
        List of floats representing the y values. Must have same length
        as x
    window : int (odd)
        Window length of datapoints. Must be odd and smaller than x
    polynom : int
        The order of polynom used. Must be smaller than the window size

    Returns
    -------
    numpy.array of float
        The smoothed y values
    """
    if len(x) != len(y):
        raise ValueError('"x" and "y" must be of the same size')

    if len(x) < window:
        raise ValueError('The data size must be larger than the window size')

    if type(window) is not int:
        raise TypeError('"window" must be an integer')

    if window % 2 == 0:
        raise ValueError('The "window" must be an odd integer')

    if type(polynom) is not int:
        raise TypeError('"polynom" must be an integer')

    if polynom >= window:
        raise ValueError('"polynom" must be less than "window"')

    half_window = window // 2
    polynom += 1

    # Initialize variables
    A = numpy.empty((window, polynom))     # Matrix
    tA = numpy.empty((polynom, window))    # Transposed matrix
    t = numpy.empty(window)                # Local x variables
    y_smoothed = numpy.full(len(y), numpy.nan)

    # Start smoothing
    for i in range(half_window, len(x) - half_window, 1):
        # Center a window of x values on x[i]
        for j in range(0, window, 1):
            t[j] = x[i + j - half_window] - x[i]

        # Create the initial matrix A and its transposed form tA
        for j in range(0, window, 1):
            r = 1.0
            for k in range(0, polynom, 1):
                A[j, k] = r
                tA[k, j] = r
                r *= t[j]

        # Multiply the two matrices
        tAA = numpy.matmul(tA, A)

        # Invert the product of the matrices
        tAA = numpy.linalg.inv(tAA)

        # Calculate the pseudoinverse of the design matrix
        coeffs = numpy.matmul(tAA, tA)

        # Calculate c0 which is also the y value for y[i]
        y_smoothed[i] = 0
        for j in range(0, window, 1):
            y_smoothed[i] += coeffs[0, j] * y[i + j - half_window]

        # If at the end or beginning, store all coefficients for the polynom
        if i == half_window:
            first_coeffs = numpy.zeros(polynom)
            for j in range(0, window, 1):
                for k in range(polynom):
                    first_coeffs[k] += coeffs[k, j] * y[j]
        elif i == len(x) - half_window - 1:
            last_coeffs = numpy.zeros(polynom)
            for j in range(0, window, 1):
                for k in range(polynom):
                    last_coeffs[k] += coeffs[k, j] * y[len(y) - window + j]

    # Interpolate the result at the left border
    for i in range(0, half_window, 1):
        y_smoothed[i] = 0
        x_i = 1
        for j in range(0, polynom, 1):
            y_smoothed[i] += first_coeffs[j] * x_i
            x_i *= x[i] - x[half_window]

    # Interpolate the result at the right border
    for i in range(len(x) - half_window, len(x), 1):
        y_smoothed[i] = 0
        x_i = 1
        for j in range(0, polynom, 1):
            y_smoothed[i] += last_coeffs[j] * x_i
            x_i *= x[i] - x[-half_window - 1]

    return y_smoothed

################################

data = numpy.loadtxt(args.infile, comments='#', unpack=True, usecols=range(0,8))



# load ICTA data for the whole time range
tmin = numpy.min(data[0])
tmax = numpy.max(data[0])

r = requests.get(url = "http://slazav.xyz:8091/get_range?name=icta&t1=%f&t2=%f" %(tmin,tmax))
icta_data = io.StringIO(r.text)
(icta_t,y,icta_w) = numpy.loadtxt(icta_data, comments='#', unpack=True, usecols=(0,2,3))

# fix broken database!
if icta_w[0]>4000: icta_w=y

# smooth
if args.sm_win > 1:
  icta_sm = non_uniform_savgol(icta_t, icta_w, args.sm_win, 3) # window size 21, polynomial order 3
  # calculate variance, remove peaks outside it
  dw = icta_sm-icta_w
  ii = numpy.abs(dw) < numpy.var(dw)
  # smooth again
  icta_st = icta_t[ii]
  icta_sw = non_uniform_savgol(icta_st, icta_w[ii], args.sm_win, 3) # window size 21, polynomial order 3
else:
  icta_st = icta_t
  icta_sw = icta_w

# skip data points
n = len(data[0])
mask = numpy.ones(n, dtype=bool)
for r in args.skip.split(','):
  a = r.split('-')
  if len(a) == 0 or a[0] == '': continue
  if len(a) == 1:
    mask[int(a[0])]=False
  else:
    if a[1] == '': a[1] = n
    mask[range(int(a[0]),int(a[1]))] = False

if not numpy.all(mask):
  data = data[:,mask]
  n = data[0].size


# interpolate do data values
icta = numpy.interp(data[0], icta_st, icta_sw)

# control plot
if args.icta_plot:
  plt.plot((icta_t-tmin)/24/3600, icta_w, 'r-', label = 'original data')
  plt.plot((icta_st-tmin)/24/3600, icta_sw, 'b-', label = 'smoothed')
  plt.plot((data[0]-tmin)/24/3600, icta, 'g*', label = 'interpolated to data points')
  plt.xlabel('time, days')
  plt.ylabel('ICTA width, Hz')
  plt.legend()
  plt.savefig(args.icta_plot)

# save file
numpy.savetxt(args.outfile, numpy.column_stack((numpy.transpose(data),icta)),
  header = "time -- freq -- drive offs -- drive amp -- phase -- amp1 -- amp2 -- amp 3 -- icta",
  fmt='%.6f %f  %e %e %e  %e %e %e %e')

