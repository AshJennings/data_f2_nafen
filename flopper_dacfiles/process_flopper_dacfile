#!/usr/bin/python3

import math
import numpy
import sys
import os
import time
import argparse
import scipy.integrate

################################
# Program takes two arguments: data directory and
# date of the first file (in YYYY-mm-dd) format
# It processes all files and writes <time>.txt files
# with averaged values as a function of phase/2*pi, [0..1)

parser = argparse.ArgumentParser()
parser.add_argument('dirname')
parser.add_argument('date')
parser.add_argument('--split_n', default=1, type=int,
                    help='split files into n parts')
parser.add_argument('--points', default=50, type=int,
                    help='number of phase points on the output')
parser.add_argument('--harm_n', default=3, type=int,
                    help='number of harmonics to be calculated')
parser.add_argument('--round_freq', default=0, type=float,
                    help='round frequency with given accuracy')
parser.add_argument('--tfiles', action='store_true',
                    help='write averaged files, signal and drive vs time')
args = parser.parse_args()

dirname = args.dirname
date = time.strptime(args.date, "%Y-%m-%d")
date = time.mktime(date)

################################
# read all *.dat files in the directory

told = 0 # starting time of the previous file
print('# time -- freq -- drive offset -- drive_amp -- sig_phase -- sig_amp1 -- sig_amp2...')
for fname in sorted(os.listdir(dirname)):
  if not fname.endswith(".dat"): continue
  fname = os.path.join(dirname, fname)
  print('# ', fname)

  ################################
  # Read file, extract time, drive, and signal (columns 0,1,9)
  # as numpy arrays.
  try:
    T,D,S = numpy.loadtxt(fname, delimiter='\t', usecols=(0,1,9), unpack=True, skiprows=4)
  except ValueError:
    print("can't read file: ", fname)
    continue

  # full time:
  if T[0] + date < told:
    date += 24*3600
  told = T[-1] + date

  for s in range(0, args.split_n):
    ################################
    # Index range

    n = T.size
    i1 = math.floor(n*s/args.split_n)
    i2 = math.floor(n*(s+1)/args.split_n)-1
    if i2 == n-1: i2+=1
    #print(i1,i2)

    T1 = T[i1:i2]
    D1 = D[i1:i2]
    S1 = S[i1:i2]
    n1 = T1.size
    tspan = T1[-1]-T1[0]
    tstep = tspan/(n1 - 1)

    ################################
    # Find drive frequency (using fft)
    fft = numpy.fft.fft(D1)
    fft[0] = 0  # remove constant component
    f_ind = numpy.argmax(numpy.abs(fft[0:int(n1/2)]))

    # fft is proportional to 1/(f-f0)
    # We want to fit 1/fft it with linear function A*x+B
    # and find zero crossing (-B/A)
    # As usual, we minimize  S = sum (a*x +b - y)^2
    # Differentiating by A and B we have
    # A*sum(x*x) + B*sum(x) - sum(y*x) =  0
    # A*sum(x) + B*sum(w) - sum(y) =  0

    # Solving this we have:
    # B = [sum(y*x)*sum(x) - sum(y)*sum(x*x)]/[sum(x)*sum(x) - sum(1)*sum(x*x)]
    # A = [sum(y)*sum(x) - sum(y*x)*sum(1)]/[sum(x)*sum(x) - sum(1)*sum(x*x)]
    # x0 = -B/A = (sum(y*x)*sum(x) - sum(y)*sum(x*x)) / (sum(y*x)*sum(1) - sum(y)*sum(x))

    # In some signals drive changes. It means there is a large low-frequency component
    # We want to skip these signals. Threshold is 0.1 Hz
    freq = f_ind / tstep / n1 # drive freq, Hz
    if freq < 0.1:
      print("non-stable drive in file: ", fname)
      continue

    # it's good to fit in a very narrow window, because 1/fft is very noisy far from f0
    ind_win = 1 #
    sn = 0
    sx = 0
    sy = 0
    sxx = 0
    sxy = 0
    for ii in range(f_ind-ind_win, f_ind+ind_win):
      x = ii - f_ind
      y = numpy.real(1/fft[ii])
      w = 1/y**2 # weight function
      sn  += w
      sx  += x*w
      sy  += y*w
      sxx += x*x*w
      sxy += x*y*w
    f_ind1 = f_ind + (sxy*sx-sy*sxx)/(sxy*sn-sy*sx)
    # Another approach, much less accurate:
    # v1 = fft[f_ind-1]
    # v2 = fft[f_ind]
    # v3 = fft[f_ind+1]
    # f_indm = f_ind - (v3-v1)/(v1 - 2*v2 + v3)/2

    freq0 = f_ind1 / tstep / n1 # drive freq, Hz
    # print("> %d %f %f" %(f_ind, f_ind1, freq0))

    if args.round_freq != 0:
      freq0 = round(freq0/args.round_freq)*args.round_freq

    ################################
    # Average points with same phase
    phV = numpy.zeros(args.points)
    phD = numpy.zeros(args.points)
    phS = numpy.zeros(args.points)
    phN = numpy.zeros(args.points)

    for i in range(T1.size):
      ph = numpy.mod(freq0*(T1[i]-T1[0]), 1) # [0..1)
      pi = math.floor(ph*args.points) # [0..args.points)
      phV[pi] += ph
      phD[pi] += D1[i]
      phS[pi] += S1[i]
      phN[pi] += 1

    # remove bins without any values
    ii = numpy.where(phN>0)
    phN = phN[ii]
    phV = phV[ii]/phN
    phS = phS[ii]/phN
    phD = phD[ii]/phN

    # periodic values
    phN = numpy.append(phN, phN[0])
    phV = numpy.append(phV, phV[0]+1)
    phD = numpy.append(phD, phD[0])
    phS = numpy.append(phS, phS[0])

    # calculate signal harmonics by doing "slow" Fourier transformation
    Dr = numpy.zeros(args.harm_n+1)
    Di = numpy.zeros(args.harm_n+1)
    Sr = numpy.zeros(args.harm_n+1)
    Si = numpy.zeros(args.harm_n+1)

    # phD1 = numpy.zeros(phD.size) # restore signals from harmonics - for test
    # phS1 = numpy.zeros(phS.size)

    for h in range(0,args.harm_n+1):
      if h==0:
        Dr[h] = numpy.average(phD)
        Sr[h] = numpy.average(phS)
        Di[h] = 0
        Si[h] = 0
        # phS1 += Sr[h]
        # phD1 += Dr[h]
      else:
        Sin = numpy.sin(h*phV*2*math.pi)
        Cos = numpy.cos(h*phV*2*math.pi)
        Dr[h] = 2*scipy.integrate.simps(Sin*phD, phV)
        Sr[h] = 2*scipy.integrate.simps(Sin*phS, phV)
        Di[h] = 2*scipy.integrate.simps(Cos*phD, phV)
        Si[h] = 2*scipy.integrate.simps(Cos*phS, phV)
        # phS1 += Sr[h]*Sin + Si[h]*Cos
        # phD1 += Dr[h]*Sin + Di[h]*Cos

    # save data
    if args.tfiles:
      numpy.savetxt('%.0f.txt' % (T1[0]+date), numpy.transpose([phV/freq0, phD, phS]),
        header = "phase -- drive -- signal" )

    # print data: time, frequency
    print("%f %f" % (T1[0]+date, freq0), end="")

    # print data: drive amplitude, phase shift between drive and signal (radians)
    if h>0:
      d_amp  = math.hypot(Dr[1],Di[1])
      d_ph  = numpy.arctan2(Di[1],Dr[1])
      s_ph  = numpy.arctan2(Si[1],Sr[1])
      ph = s_ph-d_ph
      while ph<0: ph += 2*math.pi
      while ph>=2*pi: ph -= 2*math.pi
      print("  %e %e %e" %(Dr[0], d_amp, ph), end="")

    # print data: signal harmonics (excluding constant)
    for h in range(1,args.harm_n+1):
      print("  %e" %(math.hypot(Sr[h],Si[h])), end="")

    print()


