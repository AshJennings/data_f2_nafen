#!/usr/bin/python3

import math
import numpy
import sys
import os
import time


################################
# Program takes two arguments: data directory and
# date of the first file (in YYYY-mm-dd) format
# It processes all files and writes <time>.txt files
# with averaged values as a function of phase/2*pi, [0..1)

if len(sys.argv) != 3:
  print('usage: process_flopper_dacfile <directory> YYYY-mm-dd')
  exit(1)

dirname = sys.argv[1]
date = time.strptime(sys.argv[2], "%Y-%m-%d")
date = time.mktime(date)

################################
# Files are recorded for 5 minutes. One may want to split them into smaller
# pieces (to be less sensitive to frequency stability of the drive generator
# or to increase time resolution). Parameter split_n (1,2,3,...) controls this.

split_n = 5

################################
# We are averaging all points with same phase in ph_points bins

ph_points = 100

################################
# Number of harmonics to be calculated 1,2,3...

harm_n = 3

################################

told = 0 # starting time of the previous file

################################
# read all *.dat files in the directory
for fname in os.listdir(dirname):
  if not fname.endswith(".dat"): continue
  fname = os.path.join(dirname, fname)
  print('# ', fname)

  ################################
  # Read file, extract time, drive, and signal (columns 0,1,9)
  # as numpy arrays.
  T,D,S = numpy.loadtxt(fname, delimiter='\t', usecols=(0,1,9), unpack=True, skiprows=4)

  # full time:
  if T[0] + date < told:
    date += 24*3600
  told = T[-1] + date

  for s in range(0, split_n):
    ################################
    # Index range

    n = T.size
    i1 = math.floor(n*s/split_n)
    i2 = math.floor(n*(s+1)/split_n)-1
    if i2 == n-1: i2+=1
    #print(i1,i2)

    T1 = T[i1:i2]
    D1 = D[i1:i2]
    S1 = S[i1:i2]
    n1 = T1.size
    tspan = T1[-1]-T1[0]
    tstep = tspan/(n1 - 1)

    ################################
    # Find drive frequency (using fft)
    fft = numpy.abs(numpy.fft.fft(D1))
    fft[0] = 0  # remove constant component
    f_ind = numpy.argmax(fft[0:int(n1/2)])

    # make 3-point quadratic fit, find exact max position:
    v1 = fft[f_ind-1]
    v2 = fft[f_ind]
    v3 = fft[f_ind+1]
    f_indm = f_ind - (v3-v1)/(v1 - 2*v2 + v3)/2
    freq0 = f_indm / tstep / (n1-1) # drive freq, Hz

    ################################
    # Average points with same phase
    phV = numpy.zeros(ph_points)
    phD = numpy.zeros(ph_points)
    phS = numpy.zeros(ph_points)
    phN = numpy.zeros(ph_points)

    for i in range(T1.size):
      ph = numpy.mod(freq0*(T1[i]-T1[0]), 1) # [0..1)
      pi = math.floor(ph*ph_points) # [0..ph_points)
      phV[pi] += ph
      phD[pi] += D1[i]
      phS[pi] += S1[i]
      phN[pi] += 1

    phV /= phN
    phS /= phN
    phD /= phN


    # calculate signal harmonics by doing "slow" Fourier transformation
    Dr = numpy.zeros(harm_n+1)
    Di = numpy.zeros(harm_n+1)
    Sr = numpy.zeros(harm_n+1)
    Si = numpy.zeros(harm_n+1)

    phD1 = numpy.zeros(ph_points)
    phS1 = numpy.zeros(ph_points)

    for h in range(0,harm_n+1):
      if h==0:
        Dr[h] = numpy.average(phD)
        Sr[h] = numpy.average(phS)
        Di[h] = 0
        Si[h] = 0
        phS1 += Sr[h]
        phD1 += Dr[h]
      else:
        Sin = numpy.sin(h*phV*2*math.pi)
        Cos = numpy.cos(h*phV*2*math.pi)
        Dr[h] = 2*numpy.average(Sin*phD)
        Sr[h] = 2*numpy.average(Sin*phS)
        Di[h] = 2*numpy.average(Cos*phD)
        Si[h] = 2*numpy.average(Cos*phS)

        phS1 += Sr[h]*Sin + Si[h]*Cos
        phD1 += Dr[h]*Sin + Di[h]*Cos

    # save data
    numpy.savetxt('%.0f.txt' % (T1[0]+date), numpy.transpose([phV, phD, phS, phD1, phS1]) )

    # print data
    print("%d %f %f" % (s, T1[0]+date, freq0), end="")
    for h in range(1,harm_n+1):
      print("  %e %e" %(math.hypot(Dr[h],Di[h]), math.hypot(Sr[h],Si[h])), end="")
    print()


